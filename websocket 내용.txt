1. 스트림과 스레드
스트림 (Stream):
스트림은 데이터 전송의 논리적 경로를 나타내며, 여러 데이터 흐름을 동시에 처리할 수 있는 기능을 제공합니다. HTTP/2와 HTTP/3는 멀티플렉싱을 지원하여, 하나의 연결에서 여러 스트림을 동시에 사용할 수 있습니다. 이를 통해 여러 요청과 응답이 동시에 이루어지며, 요청 간의 지연을 줄일 수 있습니다.
스레드 (Thread):
스레드는 프로세스 내에서 실행되는 경량의 실행 단위입니다. 여러 스레드를 사용하여 동시에 여러 작업을 수행할 수 있습니다. 웹 서버에서는 일반적으로 스레드를 사용하여 클라이언트의 요청을 동시에 처리합니다.
2. create_websocket_accept_key 함수
이 함수는 웹소켓 핸드셰이크 과정에서 클라이언트가 보낸 Sec-WebSocket-Key를 기반으로 서버가 생성하는 Sec-WebSocket-Accept 값을 만드는 역할을 합니다. 이 값은 클라이언트에 응답하는 HTTP 헤더에 포함되어 전송됩니다. 즉, 클라이언트가 핸드셰이크 요청을 보낼 때 제공한 키를 해싱하여 생성된 값입니다.
3. accept 함수 설명
accept 함수는 소켓 프로그래밍에서 사용되며, 서버 소켓이 클라이언트의 연결 요청을 수락하는 데 사용됩니다. 함수의 사용법은 다음과 같습니다:

c

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
sockfd: 서버 소켓의 파일 디스크립터입니다. 이 소켓은 미리 socket()과 bind() 및 listen()을 통해 설정되어 있어야 합니다.
addr: 클라이언트의 주소 정보를 저장할 구조체입니다. 이 구조체를 통해 클라이언트의 IP 주소 및 포트 번호를 알 수 있습니다.
addrlen: addr의 크기를 나타내는 변수입니다. 이 변수는 함수 호출 전후에 클라이언트의 주소 구조체 크기를 지정하고, 함수 호출 후에 실제 크기로 업데이트됩니다.
이 함수는 연결 요청이 들어올 때까지 블록(blocking) 상태에서 대기하며, 클라이언트의 연결 요청이 수락되면 새로운 소켓 파일 디스크립터를 반환합니다.

1. 바이트 스트림 구조 설명
바이트 스트림:

TCP는 데이터를 바이트의 연속적인 흐름으로 처리합니다. 이는 데이터의 경계를 명확히 하지 않으며, 애플리케이션이 데이터를 전송할 때 TCP에 의해 바이트 단위로 나누어져 전송됩니다.
수신 측에서는 이러한 바이트 스트림을 받아서 애플리케이션에 전달합니다. 이때, TCP는 각 패킷이 어떤 경계로 나누어져 있는지를 인식하지 않습니다.
헤더의 존재:

TCP/IP 프로토콜에서 각 패킷(세그먼트)에는 TCP 헤더가 포함되어 있습니다. 이 헤더는 다음과 같은 정보를 포함합니다:
출발지 포트: 데이터가 전송된 소스 포트
목적지 포트: 데이터가 전송되는 목적지 포트
순서 번호: 데이터의 순서를 추적하기 위한 번호
ACK 번호: 수신된 데이터에 대한 확인 번호
플래그: 연결 관리, 데이터 흐름 제어 등을 위한 플래그
데이터 길이: TCP 데이터의 길이
이러한 헤더는 TCP 프로토콜의 신뢰성 있는 데이터 전송을 보장하는 데 필요한 정보를 포함하고 있습니다.

1. 스트림 구조
스트림은 데이터 전송의 논리적 경로를 의미하며, 여러 데이터 흐름을 동시에 처리할 수 있는 기능을 제공합니다. HTTP/2와 HTTP/3는 멀티플렉싱을 통해 하나의 연결에서 여러 스트림을 동시에 사용할 수 있습니다.
2. Sec-WebSocket-Key와 Sec-WebSocket-Accept
클라이언트가 서버에 핸드셰이크 요청을 보낼 때 Sec-WebSocket-Key를 포함합니다.
서버는 이 키를 기반으로 Sec-WebSocket-Accept를 생성합니다. 이 과정은 다음과 같습니다:
클라이언트가 보낸 Sec-WebSocket-Key에 서버의 고정된 문자열인 258EAFA5-E914-47DA-95CA-C5AB0DC85B11을 결합합니다.
결합된 문자열을 SHA-1 해시로 변환합니다.
해시 결과를 Base64로 인코딩하여 Sec-WebSocket-Accept 값을 생성합니다.
클라이언트는 서버의 응답에서 이 Sec-WebSocket-Accept 값을 확인하여, 자신이 보낸 키와 비교함으로써 핸드셰이크가 성공적으로 이루어졌는지를 검증합니다.
3. accept 함수
accept 함수는 C의 소켓 프로그래밍에서 사용되는 함수로, POSIX 표준에 포함되어 있습니다. 이는 C의 내장 라이브러리 중 하나는 아니지만, UNIX/Linux 환경에서 소켓 프로그래밍을 위해 사용되는 표준 함수입니다.
이 함수는 클라이언트의 연결 요청을 수락하고, 새로운 소켓을 생성하여 클라이언트와의 통신을 가능하게 합니다.
4. 하나의 스레드와 여러 개의 스트림
일반적으로 하나의 스레드는 여러 개의 스트림을 동시에 처리할 수 있습니다. 예를 들어, HTTP/2에서는 하나의 TCP 연결을 통해 여러 HTTP 요청을 동시에 처리할 수 있는 멀티플렉싱 기능을 제공합니다.
그러나 스레드 내에서 여러 스트림을 처리하는 경우, 각 스트림에 대한 적절한 관리 및 동기화가 필요합니다.
5. 수신 측의 바이트 스트림
TCP는 데이터를 바이트 스트림으로 처리하며, 이 스트림은 키-값 쌍 형식이 아닙니다. 즉, 전송된 데이터는 연속적으로 흐르며, 각 패킷의 경계나 데이터의 구조를 인식하지 않습니다.
수신 측에서는 이 스트림을 받아서 애플리케이션에 전달하며, 애플리케이션이 데이터를 어떻게 해석할지는 개발자가 정의합니다.
6. 멀티플렉싱
멀티플렉싱은 하나의 연결에서 여러 데이터 스트림을 동시에 전송하는 기술입니다. HTTP/2와 HTTP/3는 멀티플렉싱을 지원하여, 여러 요청과 응답을 동시에 처리할 수 있습니다. 이를 통해 네트워크 대역폭을 효율적으로 사용할 수 있고, 요청 간의 지연을 줄일 수 있습니다.
7. 바이트 스트림 외의 데이터 전송 방식
메시지 기반 프로토콜: MQTT와 같은 프로토콜은 메시지 기반으로 작동하며, 각 메시지가 독립적으로 처리됩니다.
패킷 기반 프로토콜: UDP는 패킷 기반의 전송 방식을 사용하여, 각 패킷이 독립적으로 전송되며, 순서나 신뢰성을 보장하지 않습니다.
8. TCP 세그먼트 구조
TCP 세그먼트는 다음과 같은 구조로 구성됩니다:

TCP 헤더: 세그먼트의 시작 부분에 위치하며, 다음과 같은 정보를 포함합니다:

출발지 포트 (16 비트): 데이터가 전송된 소스 포트.
목적지 포트 (16 비트): 데이터가 전송되는 목적지 포트.
순서 번호 (32 비트): 데이터의 순서를 추적하기 위한 번호. 이 번호는 세그먼트의 첫 번째 바이트의 번호입니다.
ACK 번호 (32 비트): 수신된 데이터에 대한 확인 번호. 이 번호는 수신 측에서 다음에 기대하는 바이트의 번호입니다.
데이터 오프셋 (4 비트): TCP 헤더의 길이를 나타내며, 헤더의 끝에서 데이터 시작 위치까지의 오프셋을 나타냅니다.
플래그 (6 비트): 연결 관리, 데이터 흐름 제어 등을 위한 플래그 (예: SYN, ACK, FIN 등).
윈도우 크기 (16 비트): 수신 측에서 수신 가능한 데이터의 양을 나타내는 값.
체크섬 (16 비트): 세그먼트의 오류를 검증하기 위한 체크섬.
긴급 포인터 (16 비트): 긴급 데이터를 처리하기 위한 포인터.
데이터: TCP 헤더 다음에 오는 실제 전송 데이터. 이 데이터는 애플리케이션에서 전송한 바이트 스트림입니다.

1. 스트림의 논리적 경로
스트림은 데이터 전송의 논리적 흐름을 의미합니다. 여러 데이터 흐름을 동시에 처리할 수 있는 기능을 제공합니다. 예를 들어, HTTP/2에서는 하나의 TCP 연결을 통해 여러 HTTP 요청과 응답을 동시에 전송할 수 있습니다.

논리적 경로: 각 스트림은 독립적으로 운영되며, 서로 다른 요청과 응답이 동시에 처리됩니다. 이는 멀티플렉싱을 통해 이루어지며, 데이터는 각 스트림의 식별자에 따라 구분됩니다. 따라서 여러 사용자가 동시에 서버에 요청을 보내더라도, 각 요청과 응답이 서로 간섭하지 않고 원활하게 처리될 수 있습니다.
2. Sec-WebSocket-Key에서 "Sec"의 의미
Sec는 "Security"의 약자로, 보안 관련 헤더를 나타냅니다. 이 헤더는 웹소켓 핸드셰이크 과정에서 보안 관련 정보를 포함하고 있습니다. Sec-WebSocket-Key는 클라이언트가 서버와의 연결을 인증하기 위한 키 값을 제공하는 역할을 합니다.
3. 서버의 고정된 문자열
서버의 고정 문자열: 258EAFA5-E914-47DA-95CA-C5AB0DC85B11은 웹소켓 프로토콜에서 정의된 특정 문자열입니다. 이 문자열은 클라이언트가 보낸 Sec-WebSocket-Key와 결합하여 Sec-WebSocket-Accept 값을 생성하는 데 사용됩니다. 이 고정 문자열은 웹소켓 프로토콜의 표준에 따라 정의되어 있으며, 해시 생성의 일관성을 보장합니다.
4. SHA-1 해시 변환 예시
SHA-1 해시는 데이터를 고정된 길이의 해시 값으로 변환하는 암호화 해시 함수입니다. 예를 들어, Sec-WebSocket-Key가 dGhlIHNhbXBsZSBub25jZQ==라는 값일 때, 이 값을 고정 문자열과 결합하여 SHA-1 해시를 생성합니다.
plaintext

결합된 문자열: dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11
이 문자열을 SHA-1 해시로 변환한 후, Base64로 인코딩하여 Sec-WebSocket-Accept 값을 생성합니다. 해시 변환의 목적은 클라이언트가 보낸 키가 유효한지를 검증하는 데 사용됩니다.
5. POSIX 표준
**POSIX(Portable Operating System Interface)**는 UNIX 계열 운영체제에서 사용하는 표준입니다. 리눅스, macOS, Solaris 등 여러 운영체제에서 사용됩니다. 그러나 모든 운영체제에서 사용되는 것은 아니며, Windows와 같은 비 UNIX 계열 운영체제는 POSIX 표준을 완전히 지원하지 않을 수 있습니다.
6. 하나의 TCP 연결에서 여러 데이터 스트림
하나의 TCP 연결에서의 스트림: HTTP/2와 같은 프로토콜은 하나의 TCP 연결을 통해 여러 요청과 응답을 동시에 처리할 수 있습니다. 예를 들어, 클라이언트가 웹 페이지를 요청할 때 여러 리소스(이미지, 스크립트, 스타일시트 등)를 동시에 요청할 수 있습니다. 이 경우, 각 리소스는 별도의 스트림으로 처리되어 응답을 받을 수 있습니다.
7. MQTT 프로토콜
**MQTT (Message Queuing Telemetry Transport)**는 경량의 메시지 기반 프로토콜입니다. IoT(Internet of Things) 환경에서 주로 사용되며, 클라이언트와 브로커 간의 메시지를 효율적으로 전송하는 데 최적화되어 있습니다. MQTT는 주제 기반의 메시징을 지원하며, 퍼블리셔-구독자 모델을 사용합니다.
8. TCP 세그먼트
TCP 세그먼트는 TCP 프로토콜을 통해 전달되는 데이터의 기본 단위입니다. TCP는 데이터를 바이트 스트림으로 처리하지만, 실제 전송되는 데이터는 TCP 세그먼트라는 단위로 나누어져 전송됩니다. 각 세그먼트에는 TCP 헤더가 포함되어 있으며, 이 헤더는 전송되는 데이터의 관리 및 오류 검출을 위한 정보를 제공합니다.

바이트 스트림 vs TCP 세그먼트: TCP는 애플리케이션에 바이트 스트림을 제공하지만, 실제 전송은 세그먼트 단위로 이루어집니다. 즉, 애플리케이션이 전송하는 데이터는 TCP에 의해 여러 세그먼트로 나누어져 전송되고, 수신 측에서는 이 세그먼트를 다시 조합하여 원래의 바이트 스트림으로 복원합니다.

TCP 세그먼트 종류
TCP 세그먼트는 여러 종류의 세그먼트로 나뉘며, 주요 세그먼트의 종류는 다음과 같습니다:

데이터 세그먼트: 일반적인 데이터 전송을 위한 세그먼트로, 애플리케이션에서 전송한 데이터를 포함합니다.

SYN 세그먼트: 연결 설정을 위한 세그먼트로, 클라이언트가 서버에 연결을 요청할 때 사용됩니다. 이 세그먼트의 SYN 플래그가 설정됩니다.

ACK 세그먼트: 데이터가 성공적으로 수신되었음을 확인하기 위한 세그먼트입니다. ACK 플래그가 설정되어 있습니다.

FIN 세그먼트: 연결 종료를 요청하는 세그먼트로, 연결을 종료하고 싶을 때 사용됩니다. FIN 플래그가 설정됩니다.

RST 세그먼트: 비정상적인 상황에서 연결을 강제로 종료할 때 사용됩니다. RST 플래그가 설정되어 있습니다.

1. TCP 세그먼트 구조 예시
TCP 세그먼트는 다음과 같은 구조로 되어 있습니다:

+----------------------------------------------------+
|                  TCP Header                        |
+----------------------------------------------------+
|                   Data (Payload)                  |
+----------------------------------------------------+
TCP Header에는 다음과 같은 필드가 포함됩니다:

출발지 포트 (16 비트)
목적지 포트 (16 비트)
순서 번호 (32 비트)
ACK 번호 (32 비트)
데이터 오프셋 (4 비트)
플래그 (6 비트): SYN, ACK, FIN 등의 정보
윈도우 크기 (16 비트)
체크섬 (16 비트)
긴급 포인터 (16 비트) (필요한 경우)
예시:

출발지 포트: 12345
목적지 포트: 80
순서 번호: 1
ACK 번호: 0
데이터 오프셋: 5
플래그: SYN
윈도우 크기: 8192
체크섬: 0xABCD
데이터: "Hello, TCP!"
3. 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 문자열의 용도
이 문자열은 웹소켓 프로토콜에서 정의된 고정된 문자열로, 웹소켓 핸드셰이크 과정에서 클라이언트가 보낸 Sec-WebSocket-Key와 결합하여 Sec-WebSocket-Accept 값을 생성하는 데 사용됩니다.
이는 웹소켓 프로토콜에 특화된 문자열로, 다른 프로토콜에서는 사용되지 않습니다.
4. 해시 변환의 필요성
해시 변환을 통해 클라이언트가 보낸 Sec-WebSocket-Key와 서버의 고정 문자열을 결합하여 생성된 해시 값은 핸드셰이크의 유효성을 검증하는 데 사용됩니다.
클라이언트는 서버가 응답하는 Sec-WebSocket-Accept 값을 비교하여 연결이 유효한지를 확인합니다. 해시 변환을 하지 않으면 이 검증이 불가능해집니다. 즉, 클라이언트는 서버가 자신이 보낸 키를 알고 있다는 것을 확인할 수 없습니다.
5. TCP 송신 시 여러 세그먼트
TCP는 데이터를 바이트 스트림으로 처리하지만, 이 스트림은 여러 개의 세그먼트로 나누어져 전송됩니다.
하나의 TCP 연결에서 여러 개의 세그먼트를 생성할 수 있으며, 각 세그먼트는 TCP 헤더를 포함하여 전송됩니다. 일반적으로 애플리케이션이 전송하는 데이터는 TCP에 의해 여러 세그먼트로 나누어져 전송됩니다.
예시: 만약 애플리케이션이 1,500 바이트의 데이터를 전송한다고 가정할 때, TCP는 이 데이터를 여러 개의 세그먼트로 나누어 전송할 수 있습니다. 예를 들어, 각 세그먼트가 500 바이트라면 3개의 세그먼트로 나누어 전송됩니다.

1. 데이터 세그먼트 내부에 바이트 스트림
네, 맞습니다. TCP 세그먼트의 데이터 부분(Payload)에는 애플리케이션이 전송하고자 하는 바이트 스트림이 포함됩니다. 즉, 애플리케이션에서 전송한 데이터가 TCP 세그먼트의 데이터 필드에 담겨서 전송됩니다.
2. 클라이언트의 Sec-WebSocket-Key 전송 시 해시 변환
클라이언트는 Sec-WebSocket-Key를 전송할 때 해시 변환을 하지 않습니다. 클라이언트가 보낸 Sec-WebSocket-Key는 임의의 문자열로, 서버와의 핸드셰이크 과정에서 클라이언트가 생성하여 서버에 전달합니다.
서버는 이 키를 받으면, 클라이언트가 보낸 키를 기반으로 해시 변환을 수행하여 Sec-WebSocket-Accept 값을 생성합니다. 이 과정은 다음과 같습니다:
클라이언트가 Sec-WebSocket-Key를 생성합니다 (예: dGhlIHNhbXBsZSBub25jZQ==).
서버가 이 키에 고정 문자열 258EAFA5-E914-47DA-95CA-C5AB0DC85B11을 결합합니다.
결합된 문자열에 대해 SHA-1 해시를 계산합니다.
해시 결과를 Base64로 인코딩하여 Sec-WebSocket-Accept 값을 생성하여 클라이언트에 응답합니다.
3. 해시의 정의
**해시 (Hash)**는 입력 데이터를 고정된 길이의 데이터로 변환하는 함수입니다. 일반적으로 해시는 다음과 같은 특징을 가집니다:

고정 길이 출력: 입력 데이터의 크기에 관계없이, 해시 함수는 항상 고정된 길이의 출력을 생성합니다. 예를 들어, SHA-1 해시는 항상 160 비트(20 바이트)의 출력을 생성합니다.

일방향성: 해시 함수는 입력 데이터를 해시 값으로 변환할 수 있지만, 해시 값으로부터 원래의 입력 데이터를 복원하는 것은 불가능합니다.

충돌 저항성: 서로 다른 입력 데이터가 동일한 해시 값을 생성하는 경우(충돌)가 발생할 확률이 매우 낮아야 합니다.

빠른 계산: 해시 함수는 입력 데이터에 대해 빠르게 해시 값을 계산할 수 있어야 합니다.

1. 해시값과 키값의 관계
해시는 입력된 데이터를 고유하게 식별하기 위한 방법입니다. 예를 들어, 클라이언트가 보낸 Sec-WebSocket-Key에 대해 서버가 해시를 생성하면, 이 해시 값은 특정한 입력 (클라이언트의 키 + 고정 문자열)에 대한 고유한 출력입니다.
이를 통해 서버는 클라이언트가 보낸 키의 유효성을 검증할 수 있습니다. 즉, 클라이언트가 보낸 키와 서버가 계산한 해시가 일치하면 클라이언트의 요청이 유효하다고 판단할 수 있습니다.